diff --git a/apps/mobile/lib/avatar.ts b/apps/mobile/lib/avatar.ts
new file mode 100644
index 0000000..5d7ef54
--- /dev/null
+++ b/apps/mobile/lib/avatar.ts
@@ -0,0 +1,70 @@
+import type { SupabaseClient } from "@supabase/supabase-js";
+
+export function normalizeAvatarPath(raw: string | null | undefined, userId?: string) {
+  if (!raw) return null;
+  let s = String(raw).trim();
+  s = s.replace(/^https?:\/\/[^/]+\/storage\/v1\/object\/public\//i, "");
+  s = s.replace(/^public\//i, "");
+  s = s.replace(/^media\/avatars\//i, "avatars/");
+  if (userId) s = s.replace(/<YOUR-USER-ID>/g, userId);
+  if (!s || !/^\w+\/.+/.test(s)) return null;
+  return s;
+}
+
+export function resolveAvatarPublicUrl(
+  supabase: SupabaseClient,
+  raw: string | null | undefined,
+  opts?: { userId?: string; version?: number | string }
+) {
+  const path = normalizeAvatarPath(raw, opts?.userId);
+  if (!path) return null;
+  const slash = path.indexOf("/");
+  const bucket = path.slice(0, slash);
+  const key = path.slice(slash + 1);
+  const { data } = supabase.storage.from(bucket).getPublicUrl(key);
+  const v = opts?.version != null ? String(opts.version) : "";
+  return v ? `${data.publicUrl}?v=${encodeURIComponent(v)}` : data.publicUrl;
+}
+
+export function fallbackAvatar(name: string | null | undefined) {
+  const letter = (name || "?").trim().charAt(0).toUpperCase() || "U";
+  return `https://ui-avatars.com/api/?name=${encodeURIComponent(letter)}&background=fff&color=111&size=256&bold=true`;
+}
diff --git a/apps/owner-portal/lib/avatar.ts b/apps/owner-portal/lib/avatar.ts
new file mode 100644
index 0000000..5d7ef54
--- /dev/null
+++ b/apps/owner-portal/lib/avatar.ts
@@ -0,0 +1,70 @@
+import type { SupabaseClient } from "@supabase/supabase-js";
+
+export function normalizeAvatarPath(raw: string | null | undefined, userId?: string) {
+  if (!raw) return null;
+  let s = String(raw).trim();
+  s = s.replace(/^https?:\/\/[^/]+\/storage\/v1\/object\/public\//i, "");
+  s = s.replace(/^public\//i, "");
+  s = s.replace(/^media\/avatars\//i, "avatars/");
+  if (userId) s = s.replace(/<YOUR-USER-ID>/g, userId);
+  if (!s || !/^\w+\/.+/.test(s)) return null;
+  return s;
+}
+
+export function resolveAvatarPublicUrl(
+  supabase: SupabaseClient,
+  raw: string | null | undefined,
+  opts?: { userId?: string; version?: number | string }
+) {
+  const path = normalizeAvatarPath(raw, opts?.userId);
+  if (!path) return null;
+  const slash = path.indexOf("/");
+  const bucket = path.slice(0, slash);
+  const key = path.slice(slash + 1);
+  const { data } = supabase.storage.from(bucket).getPublicUrl(key);
+  const v = opts?.version != null ? String(opts.version) : "";
+  return v ? `${data.publicUrl}?v=${encodeURIComponent(v)}` : data.publicUrl;
+}
+
+export function fallbackAvatar(name: string | null | undefined) {
+  const letter = (name || "?").trim().charAt(0).toUpperCase() || "U";
+  return `https://ui-avatars.com/api/?name=${encodeURIComponent(letter)}&background=fff&color=111&size=256&bold=true`;
+}
diff --git a/packages/sql/migrations/0002_avatar_normalization.sql b/packages/sql/migrations/0002_avatar_normalization.sql
new file mode 100644
index 0000000..1b7c3ef
--- /dev/null
+++ b/packages/sql/migrations/0002_avatar_normalization.sql
@@ -0,0 +1,69 @@
+begin;
+
+alter table public.profiles
+  alter column avatar_url type text using avatar_url::text;
+
+update public.profiles
+set avatar_url = regexp_replace(avatar_url, '^https?://[^/]+/storage/v1/object/public/', '', 'i')
+where avatar_url ~* '^https?://';
+
+update public.profiles
+set avatar_url = regexp_replace(avatar_url, '^public/', '', 'i')
+where avatar_url ~* '^public/';
+
+update public.profiles
+set avatar_url = regexp_replace(avatar_url, '^media/avatars/', 'avatars/', 'i')
+where avatar_url ~* '^media/avatars/';
+
+update public.profiles
+set avatar_url = replace(avatar_url, '<YOUR-USER-ID>', id::text)
+where avatar_url like '%<YOUR-USER-ID>%';
+
+alter table public.profiles
+  add column if not exists avatar_version integer not null default 1;
+
+create or replace function public.bump_avatar_version() returns trigger as $$
+begin
+  if new.avatar_url is distinct from old.avatar_url then
+    new.avatar_version := coalesce(old.avatar_version, 1) + 1;
+  end if;
+  return new;
+end;
+$$ language plpgsql;
+
+drop trigger if exists trg_bump_avatar_version on public.profiles;
+create trigger trg_bump_avatar_version
+before update of avatar_url on public.profiles
+for each row execute function public.bump_avatar_version();
+
+alter table public.profiles
+  drop constraint if exists profiles_avatar_url_no_http;
+
+alter table public.profiles
+  add constraint profiles_avatar_url_no_http
+  check (avatar_url is null or avatar_url !~* '^https?://');
+
+commit;
diff --git a/README.md b/README.md
index 4b825dc..1e3b9f0 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,28 @@
 # Foodie Finder â€” MVP Starter
+
+## Avatar URL normalization (PR: fix/avatar-url-normalization)
+
+Mobile usage:
+
+```ts
+import { resolveAvatarPublicUrl, fallbackAvatar } from "@/lib/avatar";
+import { supabase } from "@/lib/supabase";
+
+const url =
+  resolveAvatarPublicUrl(supabase, profile.avatar_url, {
+    userId: profile.id,
+    version: profile.avatar_version
+  }) ?? fallbackAvatar(profile.display_name);
+```
+
+Owner portal usage:
+
+```ts
+import { resolveAvatarPublicUrl } from "@/lib/avatar";
+import { supabase } from "@/lib/supabase";
+
+const url = resolveAvatarPublicUrl(supabase, profile.avatar_url, { userId: profile.id, version: profile.avatar_version });
+```
+
